-------------------------------
 # TODO:: EX WIRE IS GOING THROUGH LARGE REFACTOR
-------------------------------
apps/ex_wire/lib/ex_wire/adapter/udp.ex:71: Expression produces a value of type 'ok' | {'error',atom()}, but this value is unmatched
apps/ex_wire/lib/ex_wire/config.ex:123: Type specification 'Elixir.ExWire.Config':'get_env!'(atom()) -> any() is a supertype of the success typing: 'Elixir.ExWire.Config':'get_env!'('chain' | 'commitment_count' | 'environment' | 'node_discovery') -> any()
apps/ex_wire/lib/ex_wire/crypto.ex:129: Invalid type specification for function 'Elixir.ExWire.Crypto':recover_public_key/3. The success typing is (binary(),<<_:512>>,0 | 1 | 2 | 3) -> binary()
apps/ex_wire/lib/ex_wire/crypto.ex:136: Type specification 'Elixir.ExWire.Crypto':node_id_from_public_key(binary()) -> binary() is a supertype of the success typing: 'Elixir.ExWire.Crypto':node_id_from_public_key(<<_:8,_:_*8>>) -> <<_:8,_:_*8>>
apps/ex_wire/lib/ex_wire/framing/frame.ex:197: Type specification 'Elixir.ExWire.Framing.Frame':padding_size(integer(),integer()) -> integer() is a supertype of the success typing: 'Elixir.ExWire.Framing.Frame':padding_size(non_neg_integer(),16) -> integer()
apps/ex_wire/lib/ex_wire/handshake.ex:60: Invalid type specification for function 'Elixir.ExWire.Handshake':new/1. The success typing is (_) -> #{'__struct__':='Elixir.ExWire.Handshake', 'ack_resp':='nil', 'auth_msg':='nil', 'encoded_ack_resp':='nil', 'encoded_auth_msg':='nil', 'init_nonce':=<<_:256>>, 'initiator':='true', 'random_key_pair':={<<_:8,_:_*8>>,binary()}, 'remote_pub':=_, 'remote_random_pub':='nil', 'resp_nonce':='nil'}
apps/ex_wire/lib/ex_wire/handshake.ex:77: Invalid type specification for function 'Elixir.ExWire.Handshake':new_response/0. The success typing is () -> #{'__struct__':='Elixir.ExWire.Handshake', 'ack_resp':='nil', 'auth_msg':='nil', 'encoded_ack_resp':='nil', 'encoded_auth_msg':='nil', 'init_nonce':='nil', 'initiator':='false', 'random_key_pair':={<<_:8,_:_*8>>,binary()}, 'remote_pub':='nil', 'remote_random_pub':='nil', 'resp_nonce':=<<_:256>>}
apps/ex_wire/lib/ex_wire/handshake.ex:93: Function generate_auth/1 has no local return
apps/ex_wire/lib/ex_wire/handshake.ex:95: The call 'Elixir.ExWire.Handshake':encode(_auth_msg@1::#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':='nil', 'initiator_nonce':=_, 'initiator_public_key':=_, 'initiator_version':=integer(), 'signature':=<<_:520>>},any(),any()) will never return since it differs in the 1st argument from the success typing arguments: (#{'__struct__':='Elixir.ExWire.Handshake.Struct.AckRespV4' | 'Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key'=><<_:8,_:_*8>>, 'initiator_nonce'=>binary(), 'initiator_public_key'=><<_:8,_:_*8>>, 'initiator_version'=>non_neg_integer(), 'recipient_ephemeral_public_key'=><<_:8,_:_*8>>, 'recipient_nonce'=>binary(), 'recipient_version'=>non_neg_integer(), 'signature'=><<_:512>>},<<_:8,_:_*8>>,'nil' | {<<_:8,_:_*8>>,binary()})
apps/ex_wire/lib/ex_wire/handshake.ex:107: Invalid type specification for function 'Elixir.ExWire.Handshake':build_auth_msg/3. The success typing is (atom() | #{'init_nonce':=binary(), 'random_key_pair':=tuple(), 'remote_pub':=<<_:8,_:_*8>>, _=>_},_,binary()) -> #{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':='nil', 'initiator_nonce':=_, 'initiator_public_key':=_, 'initiator_version':=integer(), 'signature':=<<_:520>>}
apps/ex_wire/lib/ex_wire/handshake.ex:165: The pattern {'error', _reason@1} can never match the type {'ok',#{'__struct__':='Elixir.ExWire.Handshake.Struct.AckRespV4', 'recipient_ephemeral_public_key':=<<_:8,_:_*8>>, 'recipient_nonce':=binary(), 'recipient_version':=integer()},binary(),binary()}
apps/ex_wire/lib/ex_wire/handshake.ex:187: Invalid type specification for function 'Elixir.ExWire.Handshake':handle_auth/2. The success typing is (#{'__struct__':='Elixir.ExWire.Handshake', _=>_},<<_:16,_:_*8>>) -> {'invalid','invalid_ECIES_encoded_message' | 'invalid_message_tag'}
apps/ex_wire/lib/ex_wire/handshake.ex:193: The call 'Elixir.ExWire.Handshake':add_auth_data(_handshake@1::#{'__struct__':='Elixir.ExWire.Handshake', _=>_},_auth_msg@1::#{'initiator_ephemeral_public_key':=binary(), 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_},_auth_data@1::<<_:16,_:_*8>>) breaks the contract (t(),'Elixir.ExWire.Handshake.Struct.AuthMsgV4':t(),binary()) -> t()
apps/ex_wire/lib/ex_wire/handshake.ex:205: Invalid type specification for function 'Elixir.ExWire.Handshake':add_auth_data/3. The success typing is (#{'__struct__':='Elixir.ExWire.Handshake', 'auth_msg':=_, 'encoded_auth_msg':=_, 'init_nonce':=_, 'remote_pub':=_, 'remote_random_pub':=_, _=>_},#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':=binary(), 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_},<<_:16,_:_*8>>) -> #{'__struct__':='Elixir.ExWire.Handshake', 'auth_msg':=#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':=binary(), 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_}, 'encoded_auth_msg':=<<_:16,_:_*8>>, 'init_nonce':=binary(), 'remote_pub':=<<_:8,_:_*8>>, 'remote_random_pub':=binary(), _=>_}
apps/ex_wire/lib/ex_wire/handshake.ex:224: Function generate_ack_resp/1 will never be called
apps/ex_wire/lib/ex_wire/handshake.ex:231: Function encode/3 has no local return
apps/ex_wire/lib/ex_wire/handshake.ex:234: The call 'Elixir.ExWire.Handshake.Struct.AuthMsgV4':serialize(_auth_msg@1::#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':='nil', 'initiator_nonce':=_, 'initiator_public_key':=_, 'initiator_version':=integer(), 'signature':=<<_:520>>}) breaks the contract (t()) -> 'Elixir.ExRLP':t()
apps/ex_wire/lib/ex_wire/handshake.ex:240: The pattern <_ack_resp@1 = #{'__struct__':='Elixir.ExWire.Handshake.Struct.AckRespV4'}, _remote_pub@1, _recipient_ephemeral_key_pair@1> can never match the type <#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':='nil', 'initiator_nonce':=_, 'initiator_public_key':=_, 'initiator_version':=integer(), 'signature':=<<_:520>>},_,_>
apps/ex_wire/lib/ex_wire/handshake.ex:256: Invalid type specification for function 'Elixir.ExWire.Handshake':read_auth_msg/2. The success typing is (<<_:16,_:_*8>>,binary()) -> {'error','invalid_ECIES_encoded_message' | 'invalid_message_tag'} | {'ok',#{'initiator_ephemeral_public_key':=binary(), 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_},binary()}
apps/ex_wire/lib/ex_wire/handshake/struct/auth_msg_v4.ex:36: Invalid type specification for function 'Elixir.ExWire.Handshake.Struct.AuthMsgV4':deserialize/1. The success typing is (nonempty_maybe_improper_list()) -> #{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':='nil', 'initiator_nonce':=_, 'initiator_public_key':=<<_:8,_:_*8>>, 'initiator_version':=_, 'signature':=_}
apps/ex_wire/lib/ex_wire/handshake/struct/auth_msg_v4.ex:60: Invalid type specification for function 'Elixir.ExWire.Handshake.Struct.AuthMsgV4':set_initiator_ephemeral_public_key/2. The success typing is (#{'initiator_ephemeral_public_key':=_, 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_},binary()) -> #{'initiator_ephemeral_public_key':=binary(), 'initiator_nonce':=binary(), 'initiator_public_key':=<<_:8,_:_*8>>, 'signature':=<<_:520>>, _=>_}
apps/ex_wire/lib/ex_wire/kademlia/bucket.ex:92: Invalid type specification for function 'Elixir.ExWire.Kademlia.Bucket':refresh_node/3. The success typing is (#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=map(), 'key':=binary(), 'public_key':=binary()}], 'updated_at':=integer()},#{'__struct__':='Elixir.ExWire.Struct.Peer', 'host':=atom() | string() | {'local',binary() | string()} | {byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()}, 'ident':=binary(), 'port':=char(), 'remote_id':=binary()},_) -> {'full_bucket',#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()},#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[map()], 'updated_at':=integer()}}
apps/ex_wire/lib/ex_wire/kademlia/bucket.ex:95: The call 'Elixir.ExWire.Kademlia.Bucket':reinsert_node(_bucket@1::#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()}], 'updated_at':=integer()},_node@1::#{'__struct__':='Elixir.ExWire.Struct.Peer', 'host':=atom() | string() | {'local',binary() | string()} | {byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()}, 'ident':=binary(), 'port':=char(), 'remote_id':=binary()},_options@1::any()) will never return since it differs in the 2nd argument from the success typing arguments: (#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=map(), 'key':=binary(), 'public_key':=binary()}], 'updated_at':=integer()},#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()},[{atom(),_}])
apps/ex_wire/lib/ex_wire/kademlia/bucket.ex:97: The call 'Elixir.ExWire.Kademlia.Bucket':insert_node(_bucket@1::#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()}], 'updated_at':=integer()},_node@1::#{'__struct__':='Elixir.ExWire.Struct.Peer', 'host':=atom() | string() | {'local',binary() | string()} | {byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()}, 'ident':=binary(), 'port':=char(), 'remote_id':=binary()},_options@1::any()) breaks the contract (t(),'Elixir.ExWire.Kademlia.Node':t(),'Elixir.Keyword':t()) -> t()
apps/ex_wire/lib/ex_wire/kademlia/config.ex:28: Type specification 'Elixir.ExWire.Kademlia.Config':bucket_size() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':bucket_size() -> 16
apps/ex_wire/lib/ex_wire/kademlia/config.ex:33: Type specification 'Elixir.ExWire.Kademlia.Config':concurrency() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':concurrency() -> 3
apps/ex_wire/lib/ex_wire/kademlia/config.ex:38: Type specification 'Elixir.ExWire.Kademlia.Config':id_size() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':id_size() -> 256
apps/ex_wire/lib/ex_wire/kademlia/config.ex:43: Type specification 'Elixir.ExWire.Kademlia.Config':bits_per_hop() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':bits_per_hop() -> 8
apps/ex_wire/lib/ex_wire/kademlia/config.ex:48: Type specification 'Elixir.ExWire.Kademlia.Config':eviction_check_interval() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':eviction_check_interval() -> 75
apps/ex_wire/lib/ex_wire/kademlia/config.ex:53: Type specification 'Elixir.ExWire.Kademlia.Config':request_timeout() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':request_timeout() -> 300
apps/ex_wire/lib/ex_wire/kademlia/config.ex:58: Type specification 'Elixir.ExWire.Kademlia.Config':bucket_refresh_interval() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.Config':bucket_refresh_interval() -> 3600
apps/ex_wire/lib/ex_wire/kademlia/discovery.ex:37: Invalid type specification for function 'Elixir.ExWire.Kademlia.Discovery':find_neighbours/2. The success typing is (#{'__struct__':='Elixir.ExWire.Kademlia.RoutingTable', 'buckets':=[map()], 'current_node':=#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=map(), 'key':=binary(), 'public_key':=binary()}, 'discovery_nodes':=[map()], 'discovery_round':=integer(), 'expected_pongs':=#{binary()=>{_,_}}, 'network_client_name':=pid()},atom() | #{'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, _=>_}) -> {'sent_message','Elixir.ExWire.Message.FindNeighbours' | 'Elixir.ExWire.Message.Neighbours' | 'Elixir.ExWire.Message.Ping' | 'Elixir.ExWire.Message.Pong',binary()}
apps/ex_wire/lib/ex_wire/kademlia/node.ex:67: Invalid type specification for function 'Elixir.ExWire.Kademlia.Node':new/2. The success typing is (binary(),#{'__struct__':='Elixir.ExWire.Struct.Endpoint', _=>_}) -> #{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', _=>_}, 'key':=binary(), 'public_key':=binary()}
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:89: The call 'Elixir.ExWire.Kademlia.Bucket':refresh_node(any(),_node@1::#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()}) will never return since it differs in the 2nd argument from the success typing arguments: (#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=map(), 'key':=binary(), 'public_key':=binary()}], 'updated_at':=integer()},#{'__struct__':='Elixir.ExWire.Struct.Peer', 'host':=atom() | string() | {'local',binary() | string()} | {byte(),byte(),byte(),byte()} | {char(),char(),char(),char(),char(),char(),char(),char()}, 'ident':=binary(), 'port':=char(), 'remote_id':=binary()})
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:95: The pattern {__descr@1, __node@1, _bucket@1} can never match since previous clauses completely covered the type {'full_bucket',#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()},#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[map()], 'updated_at':=integer()}}
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:167: The created fun has no local return
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:167: The call 'Elixir.ExWire.Kademlia.Bucket':'member?'(__@1::any(),_node@1::#{'__struct__':='Elixir.ExWire.Kademlia.Node', _=>_}) breaks the contract (t(),'Elixir.ExWire.Struct.Peer':t()) -> boolean()
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:181: Invalid type specification for function 'Elixir.ExWire.Kademlia.RoutingTable':ping/2. The success typing is (#{'__struct__':='Elixir.ExWire.Kademlia.RoutingTable', 'current_node':=#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, _=>_}, 'expected_pongs':=map(), 'network_client_name':=pid(), _=>_},#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, _=>_}) -> #{'__struct__':='Elixir.ExWire.Kademlia.RoutingTable', 'current_node':=#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, _=>_}, 'expected_pongs':=map(), 'network_client_name':=pid(), _=>_}
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:332: Invalid type specification for function 'Elixir.ExWire.Kademlia.RoutingTable':nodes_at/2. The success typing is (#{'__struct__':='Elixir.ExWire.Kademlia.RoutingTable', 'buckets':=[#{'__struct__':='Elixir.ExWire.Kademlia.Bucket', 'id':=integer(), 'nodes':=[any()], 'updated_at':=integer()}], 'current_node':=#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()}, 'discovery_nodes':=[#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=map(), 'key':=binary(), 'public_key':=binary()}], 'discovery_round':=integer(), 'expected_pongs':=#{binary()=>{map(),map()}}, 'network_client_name':=atom() | pid()},integer()) -> [#{'__struct__':='Elixir.ExWire.Kademlia.Node', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[any()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'key':=binary(), 'public_key':=binary()}]
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:339: Type specification 'Elixir.ExWire.Kademlia.RoutingTable':buckets_count() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.RoutingTable':buckets_count() -> 256
apps/ex_wire/lib/ex_wire/kademlia/routing_table.ex:344: Type specification 'Elixir.ExWire.Kademlia.RoutingTable':bucket_capacity() -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.RoutingTable':bucket_capacity() -> 16
apps/ex_wire/lib/ex_wire/kademlia/server.ex:27: Expression produces a value of type 'ok' | reference(), but this value is unmatched
apps/ex_wire/lib/ex_wire/kademlia/server.ex:80: Expression produces a value of type 'ok' | reference(), but this value is unmatched
apps/ex_wire/lib/ex_wire/kademlia/xor_distance.ex:45: Type specification 'Elixir.ExWire.Kademlia.XorDistance':common_prefix(binary(),binary()) -> integer() is a supertype of the success typing: 'Elixir.ExWire.Kademlia.XorDistance':common_prefix(binary(),binary()) -> non_neg_integer()
apps/ex_wire/lib/ex_wire/kademlia/xor_distance.ex:50: Type specification 'Elixir.ExWire.Kademlia.XorDistance':binary_to_bits(binary()) -> [integer()] is a supertype of the success typing: 'Elixir.ExWire.Kademlia.XorDistance':binary_to_bits(binary()) -> [0 | 1]
apps/ex_wire/lib/ex_wire/network.ex:38: Type specification 'Elixir.ExWire.Network':'receive'('Elixir.ExWire.Network.InboundMessage':t(),'Elixir.Keyword':t()) -> handler_action() is a supertype of the success typing: 'Elixir.ExWire.Network':'receive'(#{'__struct__':='Elixir.ExWire.Network.InboundMessage', 'data':=<<_:8,_:_*8>>, 'remote_host':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'server_pid':=pid(), 'timestamp':=integer()},[{atom(),_}]) -> 'no_action' | {'sent_message','Elixir.ExWire.Message.FindNeighbours' | 'Elixir.ExWire.Message.Neighbours' | 'Elixir.ExWire.Message.Ping' | 'Elixir.ExWire.Message.Pong',binary()}
apps/ex_wire/lib/ex_wire/network.ex:101: The pattern 'not_implemented' can never match the type 'no_response' | 'not_implented' | #{'__struct__':='Elixir.ExWire.Message.FindNeighbours' | 'Elixir.ExWire.Message.Neighbours' | 'Elixir.ExWire.Message.Ping' | 'Elixir.ExWire.Message.Pong', 'timestamp':=integer(), 'from'=>#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'hash'=>binary(), 'nodes'=>[#{'__struct__':='Elixir.ExWire.Struct.Neighbour', 'endpoint':=#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'node':=binary()}], 'target'=>binary(), 'to'=>#{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | non_neg_integer(), 'udp_port':='nil' | non_neg_integer()}, 'version'=>integer()}
apps/ex_wire/lib/ex_wire/network.ex:152: The specification for 'Elixir.ExWire.Network':send/3 states that the function might also return 'no_action' but the inferred return is {'sent_message','Elixir.ExWire.Message.FindNeighbours' | 'Elixir.ExWire.Message.Neighbours' | 'Elixir.ExWire.Message.Ping' | 'Elixir.ExWire.Message.Pong',binary()}
apps/ex_wire/lib/ex_wire/p2p.ex:34: Function new_outbound_connection/2 has no local return
apps/ex_wire/lib/ex_wire/p2p.ex:50: Invalid type specification for function 'Elixir.ExWire.P2P':new_inbound_connection/1. The success typing is (_) -> #{'__struct__':='Elixir.ExWire.P2P.Connection', 'handshake':=#{'__struct__':='Elixir.ExWire.Handshake', 'ack_resp':='nil', 'auth_msg':='nil', 'encoded_ack_resp':='nil', 'encoded_auth_msg':='nil', 'init_nonce':='nil', 'initiator':='false', 'random_key_pair':={<<_:8,_:_*8>>,binary()}, 'remote_pub':='nil', 'remote_random_pub':='nil', 'resp_nonce':=<<_:256>>}, 'peer':='nil', 'queued_data':=<<>>, 'secrets':='nil', 'session':='nil', 'socket':=_, 'subscribers':=[]}
apps/ex_wire/lib/ex_wire/p2p.ex:84: Expression produces a value of type #{'peer':=_, 'secrets':=#{'__struct__':='Elixir.ExWire.Framing.Secrets', 'decoder_stream':=crypto:stream_state(), 'egress_mac':={'fake',_} | {'kec',_}, 'encoder_stream':=crypto:stream_state(), 'ingress_mac':={'fake',_} | {'kec',_}, 'mac_encoder':={atom(),integer(),'cbc' | 'ctr' | 'ecb'}, 'mac_secret':=binary(), 'token':=binary()}, 'socket':=port(), _=>_}, but this value is unmatched
apps/ex_wire/lib/ex_wire/p2p.ex:142: Expression produces a value of type 'noop' | 'ok' | [any()] | {'error',atom()} | #{'peer':=_, 'secrets':=#{'__struct__':='Elixir.ExWire.Framing.Secrets', 'decoder_stream':=crypto:stream_state(), 'egress_mac':={'fake',_} | {'kec',_}, 'encoder_stream':=crypto:stream_state(), 'ingress_mac':={'fake',_} | {'kec',_}, 'mac_encoder':={atom(),integer(),'cbc' | 'ctr' | 'ecb'}, 'mac_secret':=binary(), 'token':=binary()}, 'socket':=port(), _=>_}, but this value is unmatched
apps/ex_wire/lib/ex_wire/p2p.ex:211: The pattern {'invalid', _reason@1} can never match the type {'ok',#{'__struct__':='Elixir.ExWire.Handshake', 'ack_resp':=#{'__struct__':='Elixir.ExWire.Handshake.Struct.AckRespV4', 'recipient_ephemeral_public_key':=<<_:8,_:_*8>>, 'recipient_nonce':=binary(), 'recipient_version':=integer()}, 'auth_msg':=#{'__struct__':='Elixir.ExWire.Handshake.Struct.AuthMsgV4', 'initiator_ephemeral_public_key':=<<_:8,_:_*8>>, 'initiator_nonce':=binary(), 'initiator_public_key':=binary(), 'initiator_version':=integer(), 'signature':=<<_:512>>}, 'encoded_ack_resp':=<<_:16,_:_*8>>, 'encoded_auth_msg':=binary(), 'init_nonce':=<<_:256>>, 'initiator':=boolean(), 'random_key_pair':={<<_:8,_:_*8>>,binary()}, 'remote_pub':=<<_:8,_:_*8>>, 'remote_random_pub':=<<_:8,_:_*8>>, 'resp_nonce':=<<_:256>>},#{'__struct__':='Elixir.ExWire.Framing.Secrets', 'decoder_stream':=crypto:stream_state(), 'egress_mac':={'fake',_} | {'kec',_}, 'encoder_stream':=crypto:stream_state(), 'ingress_mac':={'fake',_} | {'kec',_}, 'mac_encoder':={'Elixir.ExthCrypto.AES',32,'ecb'}, 'mac_secret':=binary(), 'token':=binary()}}
apps/ex_wire/lib/ex_wire/p2p.ex:223: The pattern {'ok', _handshake@1, _secrets@1} can never match the type {'invalid','invalid_ECIES_encoded_message' | 'invalid_message_tag'}
apps/ex_wire/lib/ex_wire/p2p.ex:256: Expression produces a value of type 'ok' | {'error',atom()}, but this value is unmatched
apps/ex_wire/lib/ex_wire/p2p.ex:261: Function send_unframed_data/3 will never be called
apps/ex_wire/lib/ex_wire/p2p.ex:279: Function get_peer_info/2 will never be called
apps/ex_wire/lib/ex_wire/p2p/server.ex:177: Expression produces a value of type 'ok' | {'error',atom()}, but this value is unmatched
apps/ex_wire/lib/ex_wire/packet/disconnect.ex:159: Guard test __@3::binary() =:= 'false' can never succeed
apps/ex_wire/lib/ex_wire/packet/hello.ex:109: Expression produces a value of type 'nil' | 'ok' | {'error',_}, but this value is unmatched
apps/ex_wire/lib/ex_wire/packet/status.ex:60: Invalid type specification for function 'Elixir.ExWire.Packet.Status':new/1. The success typing is (atom() | #{'genesis_hash':=_, 'total_difficulty':=_, _=>_}) -> #{'__struct__':='Elixir.ExWire.Packet.Status', 'best_hash':=_, 'block_number':='nil', 'genesis_hash':=_, 'manifest_hash':='nil', 'network_id':=integer(), 'protocol_version':=integer(), 'total_difficulty':=_}
apps/ex_wire/lib/ex_wire/protocol.ex:72: Type specification 'Elixir.ExWire.Protocol':sign_binary(binary(),'Elixir.ExthCrypto.Key':private_key()) -> binary() is a supertype of the success typing: 'Elixir.ExWire.Protocol':sign_binary(binary(),binary()) -> <<_:8,_:_*8>>
apps/ex_wire/lib/ex_wire/protocol.ex:98: Type specification 'Elixir.ExWire.Protocol':message_mdc(binary()) -> binary() is a supertype of the success typing: 'Elixir.ExWire.Protocol':message_mdc(<<_:64,_:_*8>>) -> <<_:256>>
apps/ex_wire/lib/ex_wire/struct/block_queue.ex:163: Invalid type specification for function 'Elixir.ExWire.Struct.BlockQueue':add_block_struct/5. The success typing is (#{'__struct__':='Elixir.ExWire.Struct.BlockQueue', 'queue':=_, _=>_},#{'__struct__':='Elixir.Blockchain.Blocktree', 'best_block':='nil' | #{'__struct__':='Elixir.Blockchain.Block', 'block_hash':='nil' | <<_:256>>, 'header':=map(), 'ommers':=[any()], 'receipts':=[any()], 'transactions':=[any()]}},atom() | #{'ommers':=[<<_:256>>], 'transactions_list':=[any()], _=>_},#{'__struct__':='Elixir.Blockchain.Chain', 'accounts':=#{<<_:160>>=>map()}, 'engine':=#{binary()=>map()}, 'evm_config':=#{'balance_cost':=non_neg_integer(), 'call_cost':=non_neg_integer(), 'clean_touched_accounts':=boolean(), 'contract_creation_cost':=non_neg_integer(), 'eip1283_sstore_gas_cost_changed':=boolean(), 'empty_account_value_transfer':=boolean(), 'exp_byte_cost':=non_neg_integer(), 'extcodecopy_cost':=non_neg_integer(), 'extcodesize_cost':=non_neg_integer(), 'has_create2':=boolean(), 'has_delegate_call':=boolean(), 'has_ec_add_builtin':=boolean(), 'has_ec_mult_builtin':=boolean(), 'has_ec_pairing_builtin':=boolean(), 'has_extcodehash':=boolean(), 'has_mod_exp_builtin':=boolean(), 'has_revert':=boolean(), 'has_shift_operations':=boolean(), 'has_static_call':=boolean(), 'increment_nonce_on_create':=boolean(), 'limit_contract_code_size':=boolean(), 'max_signature_s':='secp256k1n' | 'secp256k1n_2', 'selfdestruct_cost':=non_neg_integer(), 'should_fail_contract_creation_lack_of_gas':=boolean(), 'should_fail_nested_operation_lack_of_gas':=boolean(), 'sload_cost':=non_neg_integer(), 'status_in_receipt':=boolean(), 'support_variable_length_return_value':=boolean(), atom()=>_}, 'genesis':=#{'author':=<<_:160>>, 'difficulty':=integer(), 'extra_data':=binary(), 'gas_limit':=integer(), 'parent_hash':=<<_:256>>, 'seal':='nil' | map(), 'timestamp':=integer()}, 'name':=binary(), 'nodes':=[binary()], 'params':=#{'account_start_nonce':=integer(), 'eip1014_transition':=integer(), 'eip1052_transition':=integer(), 'eip1283_transition':=integer(), 'eip140_transition':=integer(), 'eip145_transition':=integer(), 'eip150_transition':=integer(), 'eip155_transition':=integer(), 'eip160_transition':=integer(), 'eip161abc_transition':=integer(), 'eip161d_transition':=integer(), 'eip211_transition':=integer(), 'eip214_transition':=integer(), 'eip658_transition':=integer(), 'eip86_transition':=integer(), 'eip98_transition':=integer(), 'fork_block':=integer(), 'fork_canon_hash':=<<_:256>>, 'gas_limit_bound_divisor':=integer(), 'max_code_size':=integer(), 'max_code_size_transition':=integer(), 'maximum_extra_data_size':=integer(), 'min_gas_limit':=integer(), 'network_id':=integer(), 'registrar':=<<_:160>>}},{atom(),_}) -> {#{'__struct__':='Elixir.ExWire.Struct.BlockQueue', 'do_validation':=boolean(), 'queue':=map()},#{'__struct__':='Elixir.Blockchain.Blocktree', 'best_block':='nil' | map()}}
apps/ex_wire/lib/ex_wire/struct/block_queue.ex:257: The pattern 'parent_not_found' can never match the type {'invalid',[atom()]} | {'ok',{#{'__struct__':='Elixir.Blockchain.Blocktree', 'best_block':='nil' | map()},#{'__struct__':=atom(), atom()=>_}}}
apps/ex_wire/lib/ex_wire/struct/endpoint.ex:32: Type specification 'Elixir.ExWire.Struct.Endpoint':decode('Elixir.ExRLP':t()) -> t() is a supertype of the success typing: 'Elixir.ExWire.Struct.Endpoint':decode([binary(),...]) -> #{'__struct__':='Elixir.ExWire.Struct.Endpoint', 'ip':=[integer()], 'tcp_port':='nil' | pos_integer(), 'udp_port':='nil' | pos_integer()}
apps/ex_wire/lib/ex_wire/sync.ex:84: Expression produces a value of type 'nil' | [any()], but this value is unmatched
apps/ex_wire/lib/ex_wire/sync.ex:157: Expression produces a value of type [any()], but this value is unmatched

-------------------------------
 # blockchain/block.ex warnings
 -------------------------------
apps/blockchain/lib/blockchain/block.ex:449: Function gen_child_block/2 has no local return
apps/blockchain/lib/blockchain/block.ex:449: Function gen_child_block/3 has no local return
--------------------------------
-# AccountRepo
--------------------------------
apps/blockchain/lib/blockchain/account/repo.ex:492: The inferred return type of create_contract/11 ({'error',{#{'__struct__':='Elixir.Blockchain.Account.Repo', 'cache':=map(), 'state':=map()},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[], 'refund':=0, 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)},binary()}} | {'ok',{#{'__struct__':='Elixir.Blockchain.Account.Repo', 'cache':=map(), 'state':=map()},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[any()], 'refund':=integer(), 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)},<<>>}}) has nothing in common with {'error',{#{'__struct__':=atom(), atom()=>_},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[#{'__struct__':='Elixir.EVM.LogEntry', 'address':=<<_:160>>, 'data':=binary(), 'topics':=[binary()]}], 'refund':=integer(), 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)}},binary()} | {'ok',{#{'__struct__':=atom(), atom()=>_},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[#{'__struct__':='Elixir.EVM.LogEntry', 'address':=<<_:160>>, 'data':=binary(), 'topics':=[binary()]}], 'refund':=integer(), 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)}},<<>>}, which is the expected return type for the callback of the 'Elixir.EVM.AccountRepo' behaviour
apps/evm/lib/evm/mock/mock_account_repo.ex:182: The inferred return type of create_contract/11 ({'ok',{atom() | #{'contract_result':='nil' | [any()] | map(), _=>_},_,_,_}}) has nothing in common with {'error',{#{'__struct__':=atom(), atom()=>_},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[#{'__struct__':='Elixir.EVM.LogEntry', 'address':=<<_:160>>, 'data':=binary(), 'topics':=[binary()]}], 'refund':=integer(), 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)}},binary()} | {'ok',{#{'__struct__':=atom(), atom()=>_},integer(),#{'__struct__':='Elixir.EVM.SubState', 'logs':=[#{'__struct__':='Elixir.EVM.LogEntry', 'address':=<<_:160>>, 'data':=binary(), 'topics':=[binary()]}], 'refund':=integer(), 'selfdestruct_list':='Elixir.MapSet':t(_), 'touched_accounts':='Elixir.MapSet':t(_)}},<<>>}, which is the expected return type for the callback of the 'Elixir.EVM.AccountRepo' behaviour

-------------------------------
# blockchain/block.ex warnings
-------------------------------


apps/blockchain/lib/blockchain/block.ex:724: Function add_transactions/3 has no local return
apps/blockchain/lib/blockchain/block.ex:724: The call 'Elixir.Blockchain.Block':add_transactions(_@1
::any(),_@2::any(),_@3::any(),#{'__struct__':='Elixir.EVM.Configuration.Frontier', 'contract_creatio
n_cost':=21000, 'has_delegate_call':='false'}) will never return since the success typing is (#{'__s
truct__':='Elixir.Blockchain.Block', 'block_hash':='nil' | <<_:256>>, 'header':=#{'__struct__':='Eli
xir.Block.Header', 'beneficiary':='nil' | <<_:160>>, 'difficulty':='nil' | integer(), 'extra_data':=
binary(), 'gas_limit':=integer(), 'gas_used':=integer(), 'logs_bloom':=binary(), 'mix_hash':='nil' |
 <<_:256>>, 'nonce':='nil' | <<_:64>>, 'number':='nil' | integer(), 'ommers_hash':=binary(), 'parent
_hash':=<<_:256>>, 'receipts_root':=binary(), 'state_root':=binary(), 'timestamp':='nil' | integer()
, 'transactions_root':=binary()}, 'ommers':=[#{'__struct__':='Elixir.Block.Header', 'beneficiary':='
nil' | <<_:160>>, 'difficulty':='nil' | integer(), 'extra_data':=binary(), 'gas_limit':=integer(), '
gas_used':=integer(), 'logs_bloom':=binary(), 'mix_hash':='nil' | <<_:256>>, 'nonce':='nil' | <<_:64
>>, 'number':='nil' | integer(), 'ommers_hash':=binary(), 'parent_hash':=<<_:256>>, 'receipts_root':
=binary(), 'state_root':=binary(), 'timestamp':='nil' | integer(), 'transactions_root':=binary()}],
'transactions':=[#{'__struct__':='Elixir.Blockchain.Transaction', 'data':=binary(), 'gas_limit':=int
eger(), 'gas_price':=integer(), 'init':=binary(), 'nonce':=integer(), 'r':=integer(), 's':=integer()
, 'to':=<<_:_*160>>, 'v':=integer(), 'value':=integer()}]},[],{atom(),_},atom()) -> #{'__struct__':=
'Elixir.Blockchain.Block', 'block_hash':='nil' | <<_:256>>, 'header':=#{'__struct__':='Elixir.Block.
Header', 'beneficiary':='nil' | <<_:160>>, 'difficulty':='nil' | integer(), 'extra_data':=binary(),
'gas_limit':=integer(), 'gas_used':=integer(), 'logs_bloom':=binary(), 'mix_hash':='nil' | <<_:256>>
, 'nonce':='nil' | <<_:64>>, 'number':='nil' | integer(), 'ommers_hash':=binary(), 'parent_hash':=<<
_:256>>, 'receipts_root':=binary(), 'state_root':=binary(), 'timestamp':='nil' | integer(), 'transac
tions_root':=binary()}, 'ommers':=[#{'__struct__':='Elixir.Block.Header', 'beneficiary':='nil' | <<_
:160>>, 'difficulty':='nil' | integer(), 'extra_data':=binary(), 'gas_limit':=integer(), 'gas_used':
=integer(), 'logs_bloom':=binary(), 'mix_hash':='nil' | <<_:256>>, 'nonce':='nil' | <<_:64>>, 'numbe
r':='nil' | integer(), 'ommers_hash':=binary(), 'parent_hash':=<<_:256>>, 'receipts_root':=binary(),
 'state_root':=binary(), 'timestamp':='nil' | integer(), 'transactions_root':=binary()}], 'transacti
ons':=[#{'__struct__':='Elixir.Blockchain.Transaction', 'data':=binary(), 'gas_limit':=integer(), 'g
as_price':=integer(), 'init':=binary(), 'nonce':=integer(), 'r':=integer(), 's':=integer(), 'to':=<<
_:_*160>>, 'v':=integer(), 'value':=integer()}]} and the contract is (t(),['Elixir.Blockchain.Transa
ction':t()],'Elixir.MerklePatriciaTree.DB':db(),'Elixir.EVM.Configuration':t()) -> t()
apps/blockchain/lib/blockchain/block.ex:715: Invalid type specification for function 'Elixir.Blockch
ain.Block':put_state/2. The success typing is (#{'__struct__':='Elixir.Blockchain.Block', 'header':=
#{'__struct__':='Elixir.Block.Header', 'state_root':=_, _=>_}, _=>_},atom() | #{'root_hash':=_, _=>_
}) -> #{'__struct__':='Elixir.Blockchain.Block', 'header':=#{'__struct__':='Elixir.Block.Header', 's
tate_root':=_, _=>_}, _=>_}

-------------------------------
# blockchain/account.ex
-------------------------------
apps/blockchain/lib/blockchain/account.ex

-------------------------------
apps/blockchain/lib/mix/tasks/sync/from_file.ex

-------------------------------
apps/blockchain/lib/eth_common_test/blockchain_test_runner.ex
apps/blockchain/lib/eth_common_test/state_test_runner.ex

